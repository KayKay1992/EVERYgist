==============================================================================
EDIT BLOG POST IMPLEMENTATION
==============================================================================

OVERVIEW
--------
Implemented a comprehensive edit blog post feature that allows administrators
to modify existing blog posts while preserving their metadata, handle cover
image updates, and maintain proper state management during the editing process.

KEY FEATURES
------------
1. Fetch Existing Post Data by Slug
2. Pre-populate Form with Current Values
3. Handle Cover Image Updates (Keep Existing or Upload New)
4. Update Post with Validation
5. Support Draft and Published States
6. Delete Post Functionality

==============================================================================
IMPLEMENTATION STEPS
==============================================================================

STEP 1: ROUTE SETUP
-------------------
The BlogPostEditor component accepts an `isEdit` prop to differentiate between
create and edit modes:

Route Configuration (in App.jsx):
- Create Mode: /admin/posts/new (isEdit={false})
- Edit Mode: /admin/posts/edit/:postSlug (isEdit={true})

The route passes the postSlug parameter which is used to fetch post details.

STEP 2: STATE MANAGEMENT
-------------------------
Initialize postData state with all necessary fields:

const [postData, setPostData] = useState({
  id: "",                    // Post ID for updates
  title: "",                 // Post title
  content: "",               // Markdown content
  coverImageUrl: "",         // New image file (if uploaded)
  coverPreview: "",          // Existing image URL (for display)
  tags: [],                  // Array of tags
  isDraft: "",               // Draft or published status
  generatedByAI: false,      // AI generation flag
});

Key Points:
- `coverImageUrl`: Stores new File object when user uploads
- `coverPreview`: Stores existing image URL from database
- `tags`: Initialized as array [] (NOT string) to prevent validation errors

STEP 3: FETCH POST DATA BY SLUG
--------------------------------
Created fetchPostDetailsBySlug() function to retrieve existing post data:

const fetchPostDetailsBySlug = async () => {
  try {
    const response = await axiosInstance.get(
      API_PATHS.POSTS.GET_BY_SLUG(postSlug)
    );
    if (response.data) {
      const data = response.data;
      setPostData((prevState) => ({
        ...prevState,
        id: data._id,
        title: data.title,
        content: data.content,
        coverPreview: data.coverImageUrl,  // Map to coverPreview
        tags: data.tags,
        isDraft: data.isDraft,
        generatedByAI: data.generatedByAI,
      }));
    }
  } catch (error) {
    console.error("Error fetching post details by slug:", error);
  }
};

Critical Implementation Details:
1. Used (prevState) => ({...prevState}) pattern to prevent "undefined" errors
2. Mapped data.coverImageUrl to coverPreview (not coverImageUrl)
3. This preserves existing image while allowing new uploads

Backend API Endpoint:
GET /api/posts/slug/:slug
Returns: Single post object with all fields

STEP 4: HANDLE PUBLISH/UPDATE LOGIC
------------------------------------
Modified handlePublish() function to support both create and edit modes:

const handlePublish = async (isDraft) => {
  let coverImageUrl = "";

  // Validation
  if (!postData.title.trim()) {
    setError("Post title is required.");
    return;
  }
  if (!postData.content.trim()) {
    setError("Post content is required.");
    return;
  }
  if (!isDraft) {
    // For publishing (not draft)
    if (!isEdit && !postData.coverImageUrl) {
      setError("Cover image is required for publishing post.");
      return;
    }
    if (isEdit && !postData.coverImageUrl && !postData.coverPreview) {
      setError("Cover image is required for publishing post.");
      return;
    }
    if (!postData.tags || !Array.isArray(postData.tags) || 
        postData.tags.length === 0) {
      setError("At least one tag is required for publishing post.");
      return;
    }
  }

  setLoading(true);
  setError("");

  try {
    // Handle image upload
    if (postData.coverImageUrl instanceof File) {
      // New image uploaded
      const imgUploadRes = await uploadImage(postData.coverImageUrl);
      coverImageUrl = imgUploadRes.imageUrl || "";
    } else {
      // Keep existing image
      coverImageUrl = postData.coverPreview;
    }

    const reqPayload = {
      title: postData.title,
      content: postData.content,
      coverImageUrl,
      tags: postData.tags,
      isDraft: isDraft ? true : false,
      generatedByAI: true,
    };

    // Choose endpoint based on mode
    const response = isEdit
      ? await axiosInstance.put(
          API_PATHS.POSTS.UPDATE(postData.id),
          reqPayload
        )
      : await axiosInstance.post(API_PATHS.POSTS.CREATE_POST, reqPayload);

    if (response.data) {
      toast.success(
        getToastMessageByType(
          isDraft ? "draft" : isEdit ? "edit" : "published"
        )
      );
      navigate("/admin/posts");
    }
  } catch (error) {
    console.error("Error publishing post:", error);
    setError("Failed to publish post. Please try again.");
  } finally {
    setLoading(false);
  }
};

Backend API Endpoints:
- POST /api/posts (Create new post)
- PUT /api/posts/:id (Update existing post)

STEP 5: DELETE POST FUNCTIONALITY
----------------------------------
Implemented post deletion with confirmation modal:

const handleDeletePost = async () => {
  try {
    await axiosInstance.delete(API_PATHS.POSTS.DELETE(postData.id));
    toast.success("Blog post deleted successfully");
    setOpenDeleteAlert(false);
    navigate("/admin/posts");
  } catch (error) {
    console.error("Error deleting post:", error);
    toast.error("Failed to delete blog post. Please try again.");
  }
};

Backend API Endpoint:
DELETE /api/posts/:id

STEP 6: USE EFFECT HOOK
-----------------------
Trigger appropriate actions based on mode:

useEffect(() => {
  if (isEdit) {
    fetchPostDetailsBySlug();  // Load existing post
  } else {
    generatePostIdeas();       // Generate AI ideas for new posts
  }
  return () => {};
}, [isEdit, postSlug]);

STEP 7: UI UPDATES
------------------
Conditional rendering based on isEdit prop:

1. Page Title:
   {isEdit ? "Edit Post" : "Add New Post"}

2. Publish Button:
   {isEdit ? "Update & Publish" : "Publish Post"}

3. Delete Button:
   Only shown when isEdit === true

4. CoverImageSelector:
   - Shows existing image via previewUrl={postData.coverPreview}
   - Allows uploading new image
   - Display logic: Shows image if any source exists

==============================================================================
COVER IMAGE HANDLING STRATEGY
==============================================================================

The implementation uses a dual-field approach for cover images:

1. coverImageUrl (File object):
   - Stores NEW image when user selects a file
   - Type: File or ""
   - Used for upload detection: instanceof File

2. coverPreview (String URL):
   - Stores EXISTING image URL from database
   - Type: String URL or ""
   - Used for display when no new image selected

Validation Logic:
- For CREATE mode: Require coverImageUrl (new file)
- For EDIT mode: Require EITHER coverImageUrl OR coverPreview
  (Allow keeping existing or uploading new)

Upload Logic:
if (postData.coverImageUrl instanceof File) {
  // Upload new image
  const imgUploadRes = await uploadImage(postData.coverImageUrl);
  coverImageUrl = imgUploadRes.imageUrl;
} else {
  // Keep existing image
  coverImageUrl = postData.coverPreview;
}

CoverImageSelector Component Fix:
Changed display condition from:
  !image || !preview  (Shows placeholder if ANY is missing)
To:
  !image && !preview && !previewUrl  (Shows placeholder only if ALL missing)

This ensures existing images display correctly in edit mode.

==============================================================================
LOAD MORE BUTTON FIX
==============================================================================

PROBLEM IDENTIFIED
------------------
The "Load More" button was not appearing even with 6 published posts (limit: 5
per page). Users expected to see 5 posts initially and a "Load More" button to
load the 6th post.

ROOT CAUSE
----------
Field name mismatch between backend response and frontend destructuring:

Backend Response (blogPostController.js):
const getAllPosts = async (req, res) => {
  // ... filtering logic ...
  const totalPage = Math.ceil(totalCount / limit);  // <-- totalPage (singular)
  
  res.json({
    posts,
    page,
    totalPage,      // <-- Backend returns "totalPage"
    totalCount,
    counts: { all, published, draft }
  });
};

Frontend Destructuring (BlogPosts.jsx) - BEFORE FIX:
const { posts, totalPages, counts } = response.data;  // <-- totalPages (plural)
setTotalPages(totalPages);  // <-- undefined value

Result: totalPages was undefined, so pagination logic failed:
{page < totalPages && (
  <button onClick={loadMore}>Load More</button>
)}
// Since totalPages = undefined, condition always false

THE FIX
-------
Changed frontend destructuring to match backend field name:

BEFORE:
const { posts, totalPages, counts } = response.data;
setTotalPages(totalPages);

AFTER:
const { posts, totalPage, counts } = response.data;  // Match backend
setTotalPages(totalPage);

Location: frontend/gist_hub/src/pages/Admin/BlogPosts.jsx (Line 40)

VERIFICATION
------------
Backend Configuration:
- Posts per page: 5 (limit = 5)
- Total posts: 6
- Expected totalPage: Math.ceil(6 / 5) = 2 pages

Frontend Behavior After Fix:
- Page 1: Shows 5 posts
- Load More button: Visible (because page 1 < totalPage 2)
- Clicking Load More: Fetches page 2 (remaining 1 post)
- Final state: All 6 posts displayed

Pagination Logic:
{page < totalPages && (
  <button
    onClick={() => {
      const nextPage = page + 1;
      getAllPosts(activeTab, nextPage);
    }}
  >
    Load More
  </button>
)}

STATE MANAGEMENT
----------------
const [page, setPage] = useState(1);
const [totalPages, setTotalPages] = useState(1);

setBlogPostList((prevPosts) =>
  pageNumber === 1 ? posts : [...prevPosts, ...posts]
);
// If page 1: Replace list
// If page > 1: Append to existing list

==============================================================================
KEY LESSONS LEARNED
==============================================================================

1. FIELD NAME CONSISTENCY
   - Always verify backend response field names
   - Match destructuring exactly to API response
   - Use console.log(response.data) to inspect actual structure

2. STATE UPDATE PATTERNS
   - Use (prevState) => ({...prevState}) for object updates
   - Prevents undefined errors during async operations
   - Maintains existing state while updating specific fields

3. IMAGE HANDLING IN EDIT MODE
   - Separate NEW image (File) from EXISTING image (URL)
   - Use instanceof File to detect new uploads
   - Map database field to different state property for clarity

4. VALIDATION DIFFERENCES
   - CREATE mode: Requires all fields
   - EDIT mode: Allow optional updates (keep existing or provide new)
   - Adjust validation logic based on isEdit flag

5. ARRAY INITIALIZATION
   - Always initialize arrays as [] not ""
   - Prevents Array.isArray() validation failures
   - Critical for tags, categories, etc.

6. PAGINATION DEBUGGING
   - Check both frontend and backend field names
   - Verify Math.ceil() calculations
   - Test with edge cases (exactly limit, limit + 1, etc.)

==============================================================================
TECHNICAL BENEFITS
==============================================================================

1. USER EXPERIENCE
   - Seamless editing without re-entering all data
   - Preview existing content before making changes
   - Option to keep existing image or upload new one
   - Clear feedback via toast notifications

2. DATA INTEGRITY
   - Validation prevents incomplete updates
   - Preserves metadata (author, timestamps, etc.)
   - Maintains slug consistency

3. DEVELOPER EXPERIENCE
   - Single component handles both create and edit
   - Consistent API patterns (POST for create, PUT for update)
   - Reusable validation logic

4. PERFORMANCE
   - Efficient pagination (load 5 posts at a time)
   - Only upload images when changed
   - Conditional data fetching based on mode

==============================================================================