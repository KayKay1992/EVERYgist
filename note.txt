==============================================================================
DELETE COMMENT/REPLY FUNCTIONALITY IMPLEMENTATION
==============================================================================

OVERVIEW
--------
Implemented a comprehensive delete functionality for comments and replies that
includes cascading deletion (deleting a parent comment removes all its replies),
confirmation modals for safety, and real-time UI updates. The system ensures
data consistency and provides excellent user feedback throughout the deletion
process.

KEY FEATURES
------------
1. Delete Top-Level Comments with Cascading Deletion of Replies
2. Delete Individual Nested Replies
3. Confirmation Modal Before Deletion (Prevents Accidental Deletions)
4. Cascading Delete - Parent Deletion Removes All Child Replies
5. Real-time Comment List Refresh After Deletion
6. Toast Notifications for Success/Error Feedback
7. Authentication Required for Deletion
8. Reusable Modal and DeleteAlertContent Components
9. Consistent Delete Flow for Parent Comments and Replies

==============================================================================
IMPLEMENTATION STEPS
==============================================================================

STEP 1: BACKEND - DELETE COMMENT CONTROLLER
--------------------------------------------
Implemented deleteComment() function with cascading deletion logic:

Controller Function (commentController.js):

const deleteComment = async (req, res) => {
  try {
    const { commentId } = req.params;

    // 1. Find the comment to be deleted
    const comment = await Comment.findById(commentId);
    if (!comment) {
      return res.status(404).json({ message: "Comment not found" });
    }

    // 2. Optional: Authorization check (commented out in current implementation)
    // if (comment.author.toString() !== req.user._id.toString() && 
    //     req.user.role !== 'admin') {
    //   return res.status(403).json({ 
    //     message: "Unauthorized to delete this comment" 
    //   });
    // }

    // 3. Delete the comment itself
    await comment.deleteOne({ _id: commentId });

    // 4. Cascade delete: Remove all replies to this comment
    await Comment.deleteMany({ parentComment: commentId });

    // 5. Return success response
    res.status(200).json({ 
      message: "Comment and its replies deleted successfully" 
    });
  } catch (error) {
    res.status(500).json({ 
      message: "Failed to delete comment", 
      error: error.message 
    });
  }
};

Implementation Breakdown:

1. FIND COMMENT:
   - Extract commentId from URL params
   - Query database for comment by ID
   - Return 404 if comment doesn't exist
   - Prevents deletion of non-existent comments

2. AUTHORIZATION CHECK (Optional - Currently Commented Out):
   - Verify user is comment author OR admin
   - Compare comment.author with req.user._id
   - Return 403 Forbidden if unauthorized
   - Can be enabled for production security

3. DELETE COMMENT:
   - Use deleteOne() method on comment document
   - Removes the specific comment from database
   - First step in deletion process

4. CASCADE DELETE REPLIES:
   - Use deleteMany() to remove all child replies
   - Query: { parentComment: commentId }
   - Finds all comments where parentComment equals deleted comment's ID
   - Removes entire thread in one operation
   - Ensures no orphaned replies remain

5. SUCCESS RESPONSE:
   - Return 200 status code
   - Descriptive success message
   - Frontend uses this to show confirmation

Cascading Deletion Logic Example:
----------------------------------
Before Deletion:
- Comment A (top-level)
  - Reply B (parentComment: A)
  - Reply C (parentComment: A)
- Comment D (top-level)

User Deletes Comment A:
1. DELETE Comment A (deleteOne)
2. DELETE all where parentComment === A (deleteMany)
   - Removes Reply B
   - Removes Reply C
3. Comment D remains (different top-level comment)

Result:
- Comment D (top-level)

API Endpoint Details:
- Route: DELETE /api/comments/:commentId
- Access: Private (requires authentication)
- Request Params: { commentId: "comment_id_to_delete" }
- Response (200): { message: "Comment and its replies deleted successfully" }
- Errors: 404 (comment not found), 403 (unauthorized), 500 (server error)

STEP 2: BACKEND - ROUTE REGISTRATION
-------------------------------------
Registered delete route in commentRoutes.js:

const {
    addComment,
    getCommentsByPost,
    deleteComment,  // ← Delete controller
    getAllComments,
} = require('../controllers/commentController');
const { protect } = require('../middleware/authMiddleware');

router.delete('/:commentId', protect, deleteComment);

Route Configuration:
- Method: DELETE
- Path: /:commentId (dynamic parameter)
- Middleware: protect (authentication required)
- Handler: deleteComment controller function

STEP 3: FRONTEND - API PATH CONFIGURATION
------------------------------------------
Added delete endpoint in API_PATHS utility:

COMMENTS: {
  ADD: (postId) => `/api/comments/${postId}`,
  GET_ALL_BY_POST: (postId) => `/api/comments/${postId}`,
  DELETE: (commentId) => `/api/comments/${commentId}`,  // ← Delete path
  GET_ALL: `/api/comments`,
}

Benefits:
- Centralized path management
- Dynamic commentId parameter
- Consistent usage across components
- Easy to update if API changes

STEP 4: FRONTEND - COMMENTS PAGE IMPLEMENTATION
------------------------------------------------
Implemented delete functionality in Comments.jsx (Admin Panel):

Component State:
const [comments, setComments] = useState([]);
const [openDeleteAlert, setOpenDeleteAlert] = useState({
  open: false,
  data: null,
});

State Management:
- comments: Array of all comments with nested replies
- openDeleteAlert: Object controlling delete modal
  - open: Boolean (modal visibility)
  - data: String (comment ID to delete)

Delete Comment Function:

const deleteComment = async (commentId) => {
  try {
    // 1. Make DELETE API call
    await axiosInstance.delete(API_PATHS.COMMENTS.DELETE(commentId));

    // 2. Show success notification
    toast.success("Comment Deleted Successfully");

    // 3. Close the modal and reset state
    setOpenDeleteAlert({ open: false, data: null });

    // 4. Refresh comment list
    getAllComments();
  } catch (error) {
    console.error("Error deleting comment:", error);
    // Could add error toast here
  }
};

Function Flow:
1. API CALL:
   - Call DELETE /api/comments/:commentId
   - Uses axiosInstance (includes auth headers)
   - Async/await for promise handling

2. SUCCESS NOTIFICATION:
   - Show green success toast
   - Message: "Comment Deleted Successfully"
   - Auto-dismisses after few seconds

3. MODAL CLEANUP:
   - Close confirmation modal (open: false)
   - Clear comment ID (data: null)
   - Resets state for next deletion

4. REFRESH DATA:
   - Call getAllComments() to fetch updated list
   - Re-renders UI with deleted comment removed
   - Ensures UI consistency with backend

OnDelete Callback Pattern:

{comments.map((comment) => (
  <CommentInfoCard
    key={comment._id}
    commentId={comment._id}
    authorName={comment.author.name}
    authorPhoto={comment.author.profileImageUrl}
    content={comment.content}
    updatedOn={moment(comment.updatedAt).format("Do MMM YYYY")}
    post={comment.post}
    replies={comment.replies || []}
    getAllComments={getAllComments}
    onDelete={(commentId) =>
      setOpenDeleteAlert({
        open: true,
        data: commentId || comment._id,
      })
    }
  />
))}

OnDelete Callback Explained:
- Passed to each CommentInfoCard
- When user clicks Delete button
- Opens modal and stores comment ID
- Does NOT immediately delete (safety)
- Waits for user confirmation

STEP 5: FRONTEND - CONFIRMATION MODAL
--------------------------------------
Implemented delete confirmation using Modal component:

Modal Component Usage:

<Modal
  isOpen={openDeleteAlert?.open}
  onClose={() => setOpenDeleteAlert({ open: false, data: null })}
  title="Delete Comment"
>
  <div className="w-[50vw] md:max-w-md mx-auto">
    <DeleteAlertContent
      content="Are you sure you want to delete this comment?"
      onDelete={() => deleteComment(openDeleteAlert?.data)}
    />
  </div>
</Modal>

Modal Features:
1. Conditional Rendering:
   - Only shown when openDeleteAlert.open is true
   - Hidden by default

2. Close Handler:
   - onClose resets state to { open: false, data: null }
   - User can cancel by clicking outside or close button
   - No deletion occurs on cancel

3. Title:
   - Clear modal title: "Delete Comment"
   - User knows what action they're confirming

4. Responsive Width:
   - w-[50vw]: 50% viewport width on mobile
   - md:max-w-md: Max 28rem on medium screens and up
   - Centers content with mx-auto

DeleteAlertContent Component:
-----------------------------
Reusable component for delete confirmations:

const DeleteAlertContent = ({ content, onDelete }) => {
  return (
    <div className='p-5'>
      <p className="text-[14px]">{content}</p>
      <div className="flex justify-end mt-6">
        <button
          type='button'
          className='btn-small'
          onClick={onDelete}
        >
          Delete
        </button>
      </div>
    </div>
  );
};

Component Props:
- content: String message to display
- onDelete: Function called when Delete button clicked

Usage Pattern:
<DeleteAlertContent
  content="Are you sure you want to delete this comment?"
  onDelete={() => deleteComment(openDeleteAlert?.data)}
/>

Benefits:
- Reusable across different delete scenarios
- Consistent UI for all delete confirmations
- Customizable message
- Simple, focused responsibility

STEP 6: COMMENT INFO CARD - DELETE BUTTON
------------------------------------------
Implemented delete button in CommentInfoCard component:

Delete Button UI:

<button
  className="group/btn flex items-center gap-2 text-[13px] font-semibold 
    text-rose-600 hover:text-white px-4 py-1.5 rounded-lg 
    hover:bg-linear-to-r hover:from-rose-500 hover:to-rose-600 
    cursor-pointer border border-rose-200 hover:border-rose-500 
    transition-all duration-200 hover:scale-105 hover:shadow-md ml-auto"
  onClick={() => onDelete(commentId)}
>
  <LuTrash2 className="text-[14px] group-hover/btn:scale-110 
    transition-transform" />
  <span>Delete</span>
</button>

Button Features:

1. VISUAL DESIGN:
   - Rose/red color scheme (danger action)
   - Gradient background on hover
   - Border changes on hover
   - Positioned at right end (ml-auto)

2. INTERACTIVE EFFECTS:
   - Scale animation on hover (1.05x)
   - Icon scales up on hover (1.10x)
   - Shadow appears on hover
   - Smooth transitions (200ms)

3. CLICK HANDLER:
   - onClick={() => onDelete(commentId)}
   - Calls parent's onDelete callback
   - Passes current comment's ID
   - Triggers modal opening

Nested Reply Delete Pattern:

{showSubReplies && replies?.length > 0 && (
  <div className="mt-5 ml-4 space-y-2 pl-4 border-l-2">
    {replies.map((comment, index) => (
      <CommentInfoCard
        key={comment._id}
        commentId={comment._id}
        authorName={comment.author.name}
        authorPhoto={comment.author.profileImageUrl}
        content={comment.content}
        post={comment.post}
        replies={comment.replies || []}
        isSubReply
        updatedOn={moment(comment.updatedAt).format("Do MMM YYYY")}
        onDelete={() => onDelete(comment._id)}  // ← Passes reply ID
      />
    ))}
  </div>
)}

Recursive Delete Handling:
- Each nested reply has its own Delete button
- onDelete callback passed down through props
- Clicking delete on reply passes reply's ID
- Same modal flow as parent comments
- Backend handles as single comment deletion (no replies to cascade)

STEP 7: DATA FLOW & USER EXPERIENCE
------------------------------------

DELETE PARENT COMMENT FLOW:
1. Admin navigates to Comments page
2. Comments displayed with nested replies
3. User sees parent comment with 2 replies nested below
4. User clicks "Delete" button on parent comment
5. onClick triggers: onDelete(parentCommentId)
6. setOpenDeleteAlert({ open: true, data: parentCommentId })
7. Modal appears with confirmation message
8. User sees: "Are you sure you want to delete this comment?"
9. User clicks "Delete" button in modal
10. deleteComment(parentCommentId) executes
11. API call: DELETE /api/comments/:parentCommentId
12. Backend deletes parent comment
13. Backend cascades delete to all replies (deleteMany)
14. Backend returns success message
15. Frontend shows green toast: "Comment Deleted Successfully"
16. Modal closes (setOpenDeleteAlert({ open: false, data: null }))
17. getAllComments() fetches updated list
18. UI re-renders without deleted comment and its replies
19. User sees updated comment list

DELETE NESTED REPLY FLOW:
1. Admin navigates to Comments page
2. Parent comment displayed with replies
3. User clicks "View Replies" to expand nested comments
4. Replies appear indented below parent
5. User clicks "Delete" on specific reply
6. onClick triggers: onDelete(replyCommentId)
7. setOpenDeleteAlert({ open: true, data: replyCommentId })
8. Modal appears with confirmation
9. User clicks "Delete" in modal
10. deleteComment(replyCommentId) executes
11. API call: DELETE /api/comments/:replyCommentId
12. Backend deletes reply comment
13. Backend checks for child replies (deleteMany)
14. No child replies found (replies can't have replies)
15. Backend returns success
16. Frontend shows success toast
17. Modal closes
18. getAllComments() refreshes list
19. UI re-renders with reply removed
20. Parent comment remains with other replies intact

CANCEL DELETION FLOW:
1. User clicks "Delete" button
2. Modal opens
3. User reads confirmation message
4. User changes mind
5. User clicks outside modal or close button (X)
6. onClose triggered
7. setOpenDeleteAlert({ open: false, data: null })
8. Modal closes without API call
9. Comment remains unchanged
10. No toast notification shown

==============================================================================
TECHNICAL ARCHITECTURE
==============================================================================

STATE FLOW DIAGRAM:
-------------------
User Clicks Delete
    ↓
onDelete(commentId) callback
    ↓
setOpenDeleteAlert({ open: true, data: commentId })
    ↓
Modal Renders
    ↓
User Confirms
    ↓
deleteComment(commentId)
    ↓
axiosInstance.delete(/api/comments/:commentId)
    ↓
Backend: deleteComment() controller
    ↓
Database: comment.deleteOne()
    ↓
Database: Comment.deleteMany({ parentComment: commentId })
    ↓
Backend: Success Response
    ↓
Frontend: toast.success()
    ↓
setOpenDeleteAlert({ open: false, data: null })
    ↓
getAllComments()
    ↓
UI Re-render

CALLBACK PROPAGATION:
---------------------
Comments.jsx (Parent)
  ↓ passes onDelete callback
CommentInfoCard (Parent Comment)
  ↓ passes same onDelete callback
CommentInfoCard (Nested Reply)
  ↓ calls onDelete(comment._id)
Back to Comments.jsx
  ↓ opens modal with comment ID
User Confirms
  ↓ deleteComment(commentId)
API Call → Backend → Delete

COMPONENT HIERARCHY:
--------------------
Comments.jsx (Admin Panel)
├── CommentInfoCard (Parent Comment 1)
│   ├── Delete Button → onDelete(parentId1)
│   └── Nested Replies
│       ├── CommentInfoCard (Reply 1)
│       │   └── Delete Button → onDelete(replyId1)
│       └── CommentInfoCard (Reply 2)
│           └── Delete Button → onDelete(replyId2)
├── CommentInfoCard (Parent Comment 2)
│   └── Delete Button → onDelete(parentId2)
└── Modal (Confirmation)
    └── DeleteAlertContent
        └── Delete Button → deleteComment(storedId)

CASCADING DELETION STRATEGY:
----------------------------
Database Queries:
1. Delete parent: Comment.deleteOne({ _id: parentId })
2. Delete children: Comment.deleteMany({ parentComment: parentId })

Query Execution Order:
1. First: Delete the parent comment
2. Second: Delete all replies referencing parent

Why This Order?
- Parent deletion confirms comment exists
- Child deletion can happen even if no children exist
- deleteMany returns count of deleted documents
- No errors if no children found (0 deleted)

Alternative Approaches (Not Used):
1. ON DELETE CASCADE (Database Level):
   - Would require foreign key constraints
   - MongoDB doesn't natively support CASCADE
   - Application-level cascade gives more control

2. Mongoose Middleware (Pre/Post Hooks):
   - Could use pre('remove') hook
   - Automatically delete children
   - Current approach is more explicit

3. Soft Delete:
   - Mark as deleted instead of removing
   - Keep data for audit trail
   - Could be added in future

==============================================================================
SECURITY CONSIDERATIONS
==============================================================================

AUTHENTICATION:
---------------
- protect middleware validates JWT token
- Only authenticated users can delete
- Unauthenticated requests return 401

AUTHORIZATION (Currently Disabled):
-----------------------------------
Commented out authorization check:
// if (comment.author.toString() !== req.user._id.toString() && 
//     req.user.role !== 'admin') {
//   return res.status(403).json({ 
//     message: "Unauthorized to delete this comment" 
//   });
// }

When Enabled:
- Users can only delete their own comments
- Admins can delete any comment
- Other users receive 403 Forbidden

Why Currently Disabled?
- Simplified for admin panel use
- All admin panel users assumed authorized
- Can be enabled for production security

BEST PRACTICES FOR PRODUCTION:
1. Enable authorization check
2. Implement role-based access control (RBAC)
3. Add audit logging (who deleted what when)
4. Implement soft delete for data recovery
5. Rate limit delete operations
6. Add CAPTCHA for bulk deletions

DATA INTEGRITY:
---------------
1. Comment Existence Check:
   - Verify comment exists before deleting
   - Return 404 if not found
   - Prevents errors from double-deletion

2. Cascading Delete:
   - Ensures no orphaned replies
   - Maintains referential integrity
   - Cleans up related data

3. Transaction Safety:
   - deleteOne and deleteMany are separate operations
   - Could use MongoDB transactions for atomicity
   - Current approach acceptable for use case

==============================================================================
ERROR HANDLING
==============================================================================

BACKEND ERROR HANDLING:
-----------------------
1. Comment Not Found (404):
   - Comment with given ID doesn't exist
   - Already deleted by another user
   - Invalid comment ID format

2. Unauthorized (403) - If enabled:
   - User not comment author
   - User not admin
   - Attempting to delete others' comments

3. Server Error (500):
   - Database connection issues
   - MongoDB operation failures
   - Unexpected exceptions

FRONTEND ERROR HANDLING:
------------------------
Current Implementation:
catch (error) {
  console.error("Error deleting comment:", error);
  // No user-facing error message
}

Improvement Opportunities:
catch (error) {
  console.error("Error deleting comment:", error);
  toast.error("Failed to delete comment. Please try again.");
  setOpenDeleteAlert({ open: false, data: null });
}

Enhanced Error Handling:
- Show error toast to user
- Close modal on error
- Log detailed error for debugging
- Retry mechanism for network failures

EDGE CASES HANDLED:
-------------------
1. Deleting Already Deleted Comment:
   - Backend returns 404
   - Frontend should show error (needs implementation)
   - Modal closes gracefully

2. Network Failure During Deletion:
   - API call fails
   - Comment remains in database
   - Frontend shows error (needs implementation)
   - User can retry

3. Deleting Parent with Many Replies:
   - Backend handles with deleteMany
   - All replies removed in one operation
   - Efficient for large threads

4. Concurrent Deletions:
   - Two admins delete same comment
   - First succeeds, second gets 404
   - Second deletion fails gracefully

==============================================================================
USER EXPERIENCE FEATURES
==============================================================================

1. CONFIRMATION MODAL:
   - Prevents accidental deletions
   - Clear, simple confirmation message
   - Easy to cancel (click outside or X)
   - Easy to confirm (red Delete button)

2. VISUAL FEEDBACK:
   - Delete button turns red on hover
   - Icon scales up on hover
   - Button scales on hover
   - Clear visual indicator of danger action

3. TOAST NOTIFICATIONS:
   - Immediate confirmation of success
   - Non-intrusive (auto-dismiss)
   - Positioned consistently
   - Styled appropriately (green for success)

4. REAL-TIME UPDATES:
   - Comment list refreshes after deletion
   - No need to reload page
   - Smooth UI transition
   - Consistent state between UI and backend

5. RESPONSIVE DESIGN:
   - Modal adjusts to screen size
   - Delete buttons work on all devices
   - Touch-friendly button sizes
   - Mobile-optimized modal width

6. ACCESSIBILITY:
   - Keyboard navigation supported
   - Clear button labels
   - Semantic HTML
   - Focus management in modal

==============================================================================
REUSABLE COMPONENTS
==============================================================================

1. MODAL COMPONENT:
   - Used for delete confirmations
   - Reusable for other modals
   - Customizable title and content
   - Consistent styling

2. DELETE ALERT CONTENT:
   - Reusable confirmation UI
   - Used for:
     * Delete comments
     * Delete blog posts
     * Delete any resource
   - Customizable message
   - Consistent button styling

3. COMMENT INFO CARD:
   - Recursive component
   - Handles both parents and replies
   - Consistent delete behavior
   - Single source of truth

BENEFITS OF REUSABILITY:
- Consistent UX across features
- Easier maintenance
- Less code duplication
- Faster development of new features

==============================================================================
PERFORMANCE CONSIDERATIONS
==============================================================================

1. CASCADING DELETE EFFICIENCY:
   - deleteMany() is optimized by MongoDB
   - Single query for all child deletions
   - Index on parentComment field speeds up query
   - More efficient than multiple deleteOne calls

2. FULL LIST REFRESH:
   - getAllComments() re-fetches entire list
   - Simple but potentially inefficient for large lists
   - Alternative: Remove deleted comment from state

Optimization Opportunity:
Instead of:
getAllComments()

Could use:
setComments(prevComments => 
  prevComments.filter(c => c._id !== commentId)
)

Benefits:
- No API call needed
- Instant UI update
- Reduced server load

Tradeoffs:
- Must manually handle nested replies removal
- State could drift from server
- More complex state management

3. MODAL RENDERING:
   - Modal conditionally rendered
   - Only in DOM when needed
   - Minimal performance impact

==============================================================================
FUTURE ENHANCEMENTS
==============================================================================

1. SOFT DELETE:
   - Add isDeleted flag to schema
   - Hide deleted comments instead of removing
   - Allow restore functionality
   - Maintain audit trail

2. BULK DELETE:
   - Select multiple comments
   - Delete in single operation
   - Useful for spam/moderation

3. DELETE CONFIRMATION OPTIONS:
   - "Delete comment only" vs "Delete with replies"
   - User choice for cascading
   - More granular control

4. UNDO FUNCTIONALITY:
   - Brief window to undo deletion
   - Toast with "Undo" button
   - Restore from soft delete

5. AUDIT LOGGING:
   - Log who deleted what when
   - Admin activity tracking
   - Compliance and accountability

6. OPTIMISTIC UI UPDATES:
   - Remove from UI immediately
   - Revert if API fails
   - Faster perceived performance

7. AUTHORIZATION IMPROVEMENTS:
   - Enable role-based checks
   - Add permission system
   - User-specific delete abilities

8. BETTER ERROR MESSAGING:
   - Show specific error reasons
   - Suggest corrective actions
   - Retry mechanisms

==============================================================================
LESSONS LEARNED
==============================================================================

1. CASCADING DELETES:
   - Application-level cascade gives control
   - Must be explicit about relationships
   - Consider impact on related data
   - Test thoroughly with nested data

2. CONFIRMATION MODALS:
   - Essential for destructive actions
   - Prevents costly mistakes
   - Simple confirmation sufficient
   - Don't over-complicate

3. STATE MANAGEMENT:
   - Object for modal state better than multiple booleans
   - { open: false, data: null } pattern clean
   - Easy to extend with more properties
   - Clear state transitions

4. CALLBACK PATTERNS:
   - Pass callbacks down component tree
   - Keeps delete logic centralized
   - Same callback works for all depths
   - Flexible and maintainable

5. TOAST NOTIFICATIONS:
   - Immediate feedback crucial
   - Success messages build confidence
   - Error messages need implementation
   - Auto-dismiss improves UX

6. REUSABLE COMPONENTS:
   - Modal and DeleteAlertContent highly reusable
   - Consistent UX across features
   - Easier to maintain and update
   - Plan for reusability from start

==============================================================================