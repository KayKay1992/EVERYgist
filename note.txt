Defining Comments mongoDb schema

===============================================================================
Comment MongoDB Schema Explanation
Generated: October 31, 2025
File: backend/models/Comment.js
===============================================================================

Overview
- Defines the Comment document in MongoDB using Mongoose.
- Supports threaded/nested comments via the optional parentComment field.
- Exports the model as `Comment` (collection will be `comments`).

Fields
- post: ObjectId (ref: 'BlogPost'), required
	- The blog post this comment belongs to.
- author: ObjectId (ref: 'User'), required
	- The user who wrote the comment.
- content: String, required
	- The actual comment text. Consider length validation and sanitization.
- parentComment: ObjectId (ref: 'Comment'), default: null
	- When set, this comment is a reply to another comment (enables threads).

Schema Options
- timestamps: true → Automatically adds `createdAt` and `updatedAt` fields.

Relationships
- Comment → BlogPost (many-to-one) via `post`.
- Comment → User (many-to-one) via `author`.
- Comment → Comment (self-reference) via `parentComment` for replies.

What This Enables
- Top-level comments on posts (parentComment = null).
- Replies to other comments (nested threads).
- Sorting by creation time using timestamps.

Recommended Enhancements (next steps)
- Indexes for fast queries:
	- commentSchema.index({ post: 1, createdAt: -1 });
	- commentSchema.index({ parentComment: 1, createdAt: 1 });
	- commentSchema.index({ author: 1, createdAt: -1 });
- Moderation/UX fields:
	- isDeleted: { type: Boolean, default: false }  // soft delete
	- isEdited: { type: Boolean, default: false }, editedAt: Date
	- likes: { type: Number, default: 0 }
	- status: { type: String, enum: ['visible','pending','hidden'], default: 'visible' }
	- replyCount: { type: Number, default: 0 }  // denormalized counter for speed
- Validation and hygiene:
	- Trim content and set min/max length (e.g., 1–5,000 chars).
	- Sanitize HTML if you plan to allow markdown/HTML to prevent XSS.
	- Consider rate limiting at the controller level.
- Query helpers or statics:
	- getThread(rootCommentId) to fetch a full thread efficiently.
	- listForPost(postId, { page, limit }) paginated fetch.

Example Document
{
	_id: ObjectId("..."),
	post: ObjectId("<postId>"),
	author: ObjectId("<userId>"),
	content: "This was super helpful—thanks!",
	parentComment: null,
	createdAt: "2025-10-31T12:15:00.000Z",
	updatedAt: "2025-10-31T12:15:00.000Z"
}

Common Query Patterns
// Top-level comments for a post (newest first)
Comment.find({ post: postId, parentComment: null })
	.populate('author', 'name profileImageUrl')
	.sort({ createdAt: -1 });

// Replies for a particular comment (oldest first)
Comment.find({ parentComment: commentId })
	.populate('author', 'name')
	.sort({ createdAt: 1 });

// Count all comments on a post
Comment.countDocuments({ post: postId });

Notes
- For deeply nested threads, consider limiting depth or storing a path/ancestors array for efficient tree queries.
- If enabling deletion, prefer soft deletes to preserve thread continuity.