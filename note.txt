==============================================================================
MANAGE COMMENTS PAGE IMPLEMENTATION
==============================================================================

OVERVIEW
--------
Implemented a comprehensive comments management system for administrators to
view, manage, and delete comments across all blog posts. The system features
a hierarchical comment structure with nested replies, showing parent comments
alongside their sub-replies with proper organization and visual hierarchy.

KEY FEATURES
------------
1. Display All Comments Across All Blog Posts
2. Show Associated Blog Post Information (Title + Cover Image)
3. Hierarchical Comment Display (Parent Comments + Nested Replies)
4. Delete Comments (Parent and Sub-Replies)
5. Expand/Collapse Replies
6. Reply to Comments (with Reply Input Component)
7. Real-time Date Formatting
8. Author Information Display

==============================================================================
IMPLEMENTATION STEPS
==============================================================================

STEP 1: BACKEND - COMMENT MODEL STRUCTURE
------------------------------------------
The Comment model supports hierarchical threading through the parentComment field:

Schema Definition (models/Comment.js):
const commentSchema = new mongoose.Schema({
  post: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "BlogPost",
    required: true,
  },
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  parentComment: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Comment",
    default: null,
  },
}, { timestamps: true });

Key Fields:
- post: Reference to the blog post being commented on
- author: Reference to the user who created the comment
- content: The actual comment text
- parentComment: Reference to parent comment (null for top-level comments)
- timestamps: Auto-generated createdAt and updatedAt fields

STEP 2: BACKEND - GET ALL COMMENTS ENDPOINT
--------------------------------------------
Created getAllComments() function to fetch and organize all comments with
their nested replies:

Controller Function (commentController.js):

const getAllComments = async (req, res) => {
  try {
    // 1. Fetch all comments with populated author and post details
    const comments = await Comment.find()
      .populate("author", "name profileImageUrl")
      .populate("post", "title coverImageUrl")
      .sort({ createdAt: 1 });

    // 2. Create a comment map for O(1) lookup during nesting
    const commentMap = {};
    comments.forEach((comment) => {
      comment = comment.toObject(); // Convert Mongoose doc to plain object
      comment.replies = []; // Initialize empty replies array
      commentMap[comment._id] = comment;
    });

    // 3. Nest replies under their parent comments
    const nestedComments = [];
    comments.forEach((comment) => {
      if (comment.parentComment) {
        // This is a reply - add to parent's replies array
        const parent = commentMap[comment.parentComment];
        if (parent) {
          parent.replies.push(commentMap[comment._id]);
        }
      } else {
        // This is a top-level comment - add to root array
        nestedComments.push(commentMap[comment._id]);
      }
    });

    res.json(nestedComments);
  } catch (error) {
    res.status(500).json({ 
      message: "Failed to retrieve comments", 
      error: error.message 
    });
  }
};

Algorithm Explanation:
1. Fetch all comments from database with populated references
2. Create a hash map (commentMap) for efficient lookups
3. Initialize empty replies array for each comment
4. Iterate through comments and build hierarchy:
   - If parentComment exists: Add to parent's replies array
   - If parentComment is null: Add to root nestedComments array
5. Return only top-level comments (replies are nested within)

Response Structure:
[
  {
    _id: "comment1",
    content: "Parent comment",
    author: { name: "John", profileImageUrl: "..." },
    post: { title: "Blog Post Title", coverImageUrl: "..." },
    parentComment: null,
    replies: [
      {
        _id: "comment2",
        content: "Reply to parent",
        author: { name: "Jane", profileImageUrl: "..." },
        parentComment: "comment1",
        replies: []
      }
    ]
  }
]

API Route:
GET /api/comments
Access: Private (Admin only)

STEP 3: BACKEND - DELETE COMMENT ENDPOINT
------------------------------------------
Implemented cascading delete to remove comment and all its replies:

const deleteComment = async (req, res) => {
  try {
    const { commentId } = req.params;

    const comment = await Comment.findById(commentId);
    if (!comment) {
      return res.status(404).json({ message: "Comment not found" });
    }

    // Delete the comment itself
    await comment.deleteOne({ _id: commentId });

    // Delete all replies to this comment (cascade delete)
    await Comment.deleteMany({ parentComment: commentId });

    res.status(200).json({ 
      message: "Comment and its replies deleted successfully" 
    });
  } catch (error) {
    res.status(500).json({ 
      message: "Failed to delete comment", 
      error: error.message 
    });
  }
};

Key Features:
- Validates comment exists before deletion
- Deletes parent comment
- Cascades deletion to all child replies (one level)
- Returns success confirmation

API Route:
DELETE /api/comments/:commentId
Access: Private (Admin only)

STEP 4: FRONTEND - API PATHS CONFIGURATION
-------------------------------------------
Added comment endpoints to API_PATHS utility:

COMMENTS: {
  ADD: (postId) => `/api/comments/${postId}`,
  GET_ALL_BY_POST: (postId) => `/api/comments/${postId}`,
  DELETE: (commentId) => `/api/comments/${commentId}`,
  GET_ALL: `/api/comments`,
}

STEP 5: FRONTEND - COMMENTS PAGE COMPONENT
-------------------------------------------
Created Comments.jsx page to manage all comments:

Component Structure (pages/Admin/Comments.jsx):

import React, { useState, useEffect } from "react";
import DashboardLayout from "../../components/layouts/DashboardLayout";
import CommentInfoCard from "../../components/Cards/CommentInfoCard";
import axiosInstance from "../../utils/axioInstance";
import { API_PATHS } from "../../utils/apiPaths";
import moment from "moment";

const Comments = () => {
  const navigate = useNavigate();
  const [comments, setComments] = useState([]);
  const [openDeleteAlert, setOpenDeleteAlert] = useState({
    open: false,
    data: null,
  });

  // Fetch all comments from backend
  const getAllComments = async () => {
    try {
      const response = await axiosInstance.get(API_PATHS.COMMENTS.GET_ALL);
      setComments(response.data?.length > 0 ? response.data : []);
    } catch (error) {
      console.error("Error fetching comments:", error);
    }
  };

  // Delete comment handler (to be implemented)
  const deleteComment = async (commentId) => {
    // Will handle deletion with confirmation modal
  };

  // Fetch comments on component mount
  useEffect(() => {
    getAllComments();
    return () => {};
  }, []);

  return (
    <DashboardLayout activeMenu="Comments">
      <div className="w-auto sm:max-w-[900px] mx-auto">
        <h2 className="text-2xl font-semibold mt-5 mb-5">Comments</h2>

        {comments.map((comment) => (
          <CommentInfoCard
            key={comment._id}
            commentId={comment._id}
            authorName={comment.author.name}
            authorPhoto={comment.author.profileImageUrl}
            content={comment.content}
            updatedOn={
              comment.updatedAt 
                ? moment(comment.updatedAt).format("Do MMM YYYY") 
                : "-"
            }
            post={comment.post}
            replies={comment.replies || []}
            getAllComments={getAllComments}
            onDelete={(commentId) =>
              setOpenDeleteAlert({
                open: true,
                data: commentId || comment._id,
              })
            }
          />
        ))}
      </div>
    </DashboardLayout>
  );
};

Key Implementation Details:
1. State Management:
   - comments: Array of comment objects with nested replies
   - openDeleteAlert: Object with open status and comment ID

2. getAllComments():
   - Fetches all comments via API
   - Sets empty array if no comments returned
   - Error handling with console logging

3. Rendering:
   - Maps through top-level comments only
   - Passes replies array to CommentInfoCard (handled recursively)
   - Formats date using moment.js
   - onDelete triggers modal with comment ID

STEP 6: COMMENT INFO CARD COMPONENT
------------------------------------
Created reusable CommentInfoCard component for displaying comments:

Component Props:
- commentId: Unique comment identifier
- authorName: Name of comment author
- authorPhoto: Profile image URL
- content: Comment text
- updatedOn: Formatted date string
- post: Associated blog post object (title, coverImageUrl)
- replies: Array of nested reply comments
- getAllComments: Function to refresh comment list
- onDelete: Callback function for deletion
- isSubReply: Boolean to differentiate parent vs. reply styling

Component Features (CommentInfoCard.jsx):

const CommentInfoCard = ({
  commentId,
  authorName,
  authorPhoto,
  content,
  updatedOn,
  post,
  replies,
  getAllComments,
  onDelete,
  isSubReply,
}) => {
  const { user } = useContext(UserContext);
  const [replyText, setReplyText] = useState("");
  const [showReplyForm, setShowReplyForm] = useState(false);
  const [showSubReplies, setShowSubReplies] = useState(false);

  // 1. PARENT COMMENT DISPLAY
  return (
    <div className={`bg-white p-3 rounded-lg cursor-pointer group ${
      isSubReply ? "mb-1" : "mb-4"
    }`}>
      <div className="grid grid-cols-12 gap-3">
        {/* Left Section: Comment Content */}
        <div className="col-span-12 md:col-span-6 lg:col-span-8 flex gap-3 order-2 md:order-1">
          <img 
            src={authorPhoto} 
            alt={authorName} 
            className="w-10 h-10 rounded-full" 
          />
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h3 className="text-[12px] text-gray-500 font-medium">
                @{authorName}
              </h3>
              <LuDot className="text-gray-500" />
              <span className="text-[12px] text-gray-500 font-medium">
                {updatedOn}
              </span>
            </div>
            <p className="text-sm text-black font-medium">{content}</p>

            {/* Action Buttons */}
            <div className="flex items-center gap-3 mt-1.5">
              {!isSubReply && (
                <>
                  {/* Reply Button */}
                  <button
                    className="flex items-center gap-2 text-[13px] font-medium text-sky-950 px-4 py-0.5 rounded-full hover:bg-sky-500 hover:text-white cursor-pointer"
                    onClick={() => setShowReplyForm((prev) => !prev)}
                  >
                    <LuReply /> Reply
                  </button>

                  {/* Show/Hide Replies Button */}
                  <button
                    className="flex items-center gap-1.5 text-[13px] font-medium px-4 py-0.5 text-sky-950 bg-sky-50 rounded-full hover:bg-sky-500 hover:text-white cursor-pointer"
                    onClick={() => setShowSubReplies((prev) => !prev)}
                  >
                    {replies?.length || 0}
                    {replies?.length == 1 ? " reply" : " replies"}
                    <LuChevronDown
                      className={`${showSubReplies ? "rotate-180" : ""}`}
                    />
                  </button>
                </>
              )}

              {/* Delete Button */}
              <button
                className="flex items-center gap-1.5 text-[13px] font-medium text-sky-950 bg-sky-50 px-4 py-0.5 rounded-full hover:bg-rose-500 hover:text-white cursor-pointer"
                onClick={() => onDelete(commentId)}
              >
                <LuTrash2 /> Delete
              </button>
            </div>
          </div>
        </div>

        {/* Right Section: Associated Blog Post (only for parent comments) */}
        {!isSubReply && (
          <div className="col-span-12 md:col-span-6 lg:col-span-4 order-1 md:order-2 flex items-center gap-1.5">
            <img
              src={post?.coverImageUrl}
              alt="post cover"
              className="w-10 h-10 rounded-md object-cover"
            />
            <div className="flex-1">
              <h4 className="text-xs text-gray-500 font-medium">
                {post?.title}
              </h4>
            </div>
          </div>
        )}
      </div>

      {/* 2. REPLY INPUT FORM (shown when Reply button clicked) */}
      {!isSubReply && showReplyForm && (
        <CommentReplyInput
          user={user}
          authorName={authorName}
          content={content}
          replyText={replyText}
          setReplyText={setReplyText}
          handleAddReply={handleAddReply}
          handleCancelReply={handleCancelReply}
        />
      )}

      {/* 3. NESTED REPLIES (recursive rendering) */}
      {showSubReplies &&
        replies?.length > 0 &&
        replies.map((comment, index) => (
          <div key={comment._id} className={`ml-3 ${index == 0 ? "mt-5" : ""}`}>
            <CommentInfoCard
              commentId={comment._id}
              authorName={comment.author.name}
              authorPhoto={comment.author.profileImageUrl}
              content={comment.content}
              post={comment.post}
              replies={comment.replies || []}
              isSubReply={true}
              updatedOn={
                comment.updatedAt
                  ? moment(comment.updatedAt).format("Do MMM YYYY")
                  : "-"
              }
              onDelete={() => onDelete(comment._id)}
            />
          </div>
        ))}
    </div>
  );
};

STEP 7: KEY IMPLEMENTATION PATTERNS
------------------------------------

1. RECURSIVE COMPONENT RENDERING
   The CommentInfoCard component renders itself recursively for nested replies:
   
   - Parent Comment (isSubReply = false):
     * Shows blog post information
     * Shows Reply and View Replies buttons
     * Can expand/collapse reply form and replies list
   
   - Sub-Reply (isSubReply = true):
     * Hides blog post information
     * Hides Reply and View Replies buttons
     * Shows only content and Delete button
     * Indented with ml-3 margin

2. CONDITIONAL RENDERING
   - Blog Post Section: Only shown for parent comments (!isSubReply)
   - Action Buttons: Reply/View Replies hidden for sub-replies
   - Reply Form: Only shown when showReplyForm is true
   - Replies List: Only shown when showSubReplies is true

3. STATE MANAGEMENT
   - showReplyForm: Toggle reply input visibility
   - showSubReplies: Toggle nested replies visibility
   - replyText: Store reply input value

4. DELETE HANDLER PATTERN
   Fixed onDelete prop confusion:
   
   BEFORE (INCORRECT):
   - Props: openDelete (wrong name)
   - Usage: onDelete() (no argument passed)
   
   AFTER (CORRECT):
   - Props: onDelete (correct name)
   - Parent Comment: onClick={() => onDelete(commentId)}
   - Sub-Reply: onDelete={() => onDelete(comment._id)}
   
   This ensures the correct comment ID is passed up the chain to trigger
   the delete modal in the parent Comments page.

5. CALLBACK FLOW
   Comments.jsx → CommentInfoCard (Parent) → CommentInfoCard (Reply)
   
   When delete clicked on any comment:
   1. CommentInfoCard calls onDelete(commentId)
   2. Comments.jsx receives commentId
   3. Sets openDeleteAlert state with comment ID
   4. Shows confirmation modal (to be implemented)
   5. On confirm: Calls deleteComment(commentId)
   6. Refreshes list via getAllComments()

==============================================================================
RESPONSIVE DESIGN IMPLEMENTATION
==============================================================================

Grid Layout:
- Mobile: Single column, blog post info appears above comment
- Tablet/Desktop: Split layout (8 cols content, 4 cols post info)

Column Order:
- order-2 md:order-1: Comment content (left on desktop, bottom on mobile)
- order-1 md:order-2: Blog post info (right on desktop, top on mobile)

Spacing:
- Parent Comments: mb-4 (larger margin)
- Sub-Replies: mb-1 (compact spacing)
- First Reply: mt-5 (top margin for separation)
- Nested Indent: ml-3 (left margin for visual hierarchy)

Button Responsiveness:
- Text labels hidden on small screens
- Icons always visible
- Smooth hover transitions with scale effect

==============================================================================
DATA FLOW SUMMARY
==============================================================================

1. FETCHING COMMENTS
   Backend: Comment.find() → populate author/post → nest replies → return
   Frontend: getAllComments() → setComments(nestedComments)

2. DISPLAYING COMMENTS
   Comments.jsx maps top-level comments
   → CommentInfoCard receives comment + replies
   → Recursively renders sub-replies when expanded

3. DELETING COMMENTS
   User clicks Delete
   → onDelete(commentId) triggered
   → Comments.jsx receives ID via callback
   → setOpenDeleteAlert({ open: true, data: commentId })
   → Modal shown (to be implemented)
   → On confirm: DELETE /api/comments/:commentId
   → Backend deletes comment + cascades to replies
   → Frontend calls getAllComments() to refresh

==============================================================================
KEY BENEFITS
==============================================================================

1. HIERARCHICAL ORGANIZATION
   - Clear parent-child relationship
   - Visual indentation for replies
   - Expandable/collapsible threads

2. EFFICIENT DATA STRUCTURE
   - Server-side nesting reduces client-side processing
   - O(1) lookup using comment map
   - Single API call for all comments

3. REUSABLE COMPONENTS
   - CommentInfoCard handles both parent and reply rendering
   - Recursive pattern eliminates code duplication
   - Flexible prop-based configuration

4. USER EXPERIENCE
   - See all comments across all posts in one view
   - Quick context via blog post thumbnail and title
   - Inline actions (reply, delete, expand/collapse)
   - Real-time date formatting

5. ADMIN CAPABILITIES
   - Centralized comment moderation
   - Delete any comment (with cascade to replies)
   - View comment distribution across posts
   - Quick access to comment context

==============================================================================
LESSONS LEARNED - PROP NAMING BUG FIX
==============================================================================

THE BUG:
In CommentInfoCard component, the onDelete prop was incorrectly named in the
destructuring but used correctly in the JSX, causing confusion and errors.

BEFORE (INCORRECT):
const CommentInfoCard = ({
  ...otherProps,
  openDelete,  // ❌ Wrong prop name
  isSubReply,
}) => {
  // JSX tried to call onDelete() but it wasn't defined
  <button onClick={() => onDelete()}>Delete</button>  // ❌ Undefined function
};

AFTER (CORRECT):
const CommentInfoCard = ({
  ...otherProps,
  onDelete,  // ✅ Correct prop name matches parent
  isSubReply,
}) => {
  // Now onDelete is properly defined and can be called
  <button onClick={() => onDelete(commentId)}>Delete</button>  // ✅ Works
};

ROOT CAUSE:
Copy-paste error or autocomplete mistake during initial development led to
prop name mismatch between parent component passing onDelete and child
component expecting openDelete.

THE FIX:
1. Changed destructured prop name from openDelete → onDelete (line 21)
2. Added commentId argument: onDelete() → onDelete(commentId) (line 96)
3. Ensured consistency across parent and sub-reply components

LESSON:
Always verify prop names match exactly between parent and child components.
Use TypeScript or PropTypes to catch these errors during development.

==============================================================================